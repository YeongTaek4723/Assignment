<html>
    <head>
        <title>2week_2 Assignment</title>
    </head>
    <body>
        <p style = "font-size : x-large">11. merge<hr>
            <ul>
                <li><b>merge란?</b>
                    <p>merge는 각 분기된 커밋을 하나의 커밋으로 다시 합치고 싶을 때 사용하는 명령어이다.</p>
                <li><b>merge 기본 사용법</b>
                    <p>기본적으로 merge를 하기위해 기본이 되는 커밋을 선택해 해당 커밋으로 체크아웃을 한다.<br><br>
                    -<b>merge 방법</b><br>
                    -> <b>git merge [브랜치이름]</b></p>
                <li><b>merge 종류</b><br><br>
                    <ul>
                        <li><b>fast-forward</b>
                            <p>fast-forward란 뿌리가 되는 브랜치에 변화가 주어지지 않은 채 다른 변화가 생긴 브랜치로 머지를 하게되는 것이다.<br>
                            그러면 새로운 커밋이 생성되지 않고 머지를 한 대상 브랜치의 마지막 커밋에 뿌리가 되는 브랜치가 자리잡게 된다.</p>
                        <li><b>fast-forward가 아닌것</b>
                            <p>fast-forward가 아니므로 새로운 커밋을 생성해 그곳에 머지를 하게된다.</p>
                    </ul>
                <li><b>충돌</b>
                    <p>머지를 할 경우 충돌의 위험이 있을 수 있다. 충돌은 다음 경우에 생긴다.<br>
                        -> 각 브랜치에서 같은 파일의 이름으로 그 내용이 다른데 머지를 시도할 경우 충돌 발생<br><br>
                    충돌이 발생하게 되면 index파일에는 그 둘 브랜치 사이의 base커밋의 파일 내용과 각 브랜치의 커밋의 서로 다른 파일의 내용을 참조해서 총 세개의 파일 내용을 참조하게 된다.<br>
                    이 문제를 깃은 3way-merge방법을 통해 충돌을 해결하려고 시도한다.<br>
                    하지만 같은 파일인데 내용이 서로 상이하게 바뀌었을 경우는 깃에서 해결을 하지 못하고 충돌 에러를 발생시킨다. 그러면 이는 사용자가 직접 수정해야 된다.<br><br>
                    이렇게 사용자가 직접 수정을 해야되는 경우 그나마 조금 사용자가 수정을 위한 편의를 위해 도와주는 툴이 존재한다.<br><br>
                    -<b>충동 해결 툴 설치 방법</b><br>
                        -> <b>git config --global merge.tool [툴이름(kdiff3)]</b><br><br>
                    -<b>툴 실행 방법</b><br>
                        -> <b>git mergetool</b></p>
            </ul><hr><br>
        <p style = "font-size : x-large">12. conflict</p><hr>
            <ul>
                <li><b>conflict란</b>
                    <p>위 11. merge의 충돌에 설명이있다. 간단하게 말하자면 서로 다른 개발자가 브랜치를 나누어 작업을 하는데 같은 파일의 같은 줄을 다른 내용으로 수정하고 머지를 하는 과정에서 에러<br>
                    즉, conflict가 날 수 있다.</p>
                <li><b>해결 방법</b>
                    <p>conflict가 발생한 파일을 들어가 보면 다음과 같이<br>
                    <<<<<<< head<br>
                    ==============<br>
                    >>>>>>> test(병합(merge)하려는 브랜치)<br>
                    표시가 보인다.<br><br>
                    <<<<, =======, >>>> 이 표시들을 지워주고, 코드만 남겨 저장하면 된다. 두 코드 모두 남겨도 되며 하나만 남겨도 된다.</p>
                <li><b>VScode로 conflict 해결하기</b>
                    <p><b>git config --global -e</b>명령어로 들어가서 다음 4줄을 추가한다.<br><br>
                    <b>[merge]<br>
                        &nbsp;&nbsp;tool = VScode<br>
                        [mergetool "vscode"]<br>
                    &nbsp;&nbsp;cmd = code --wait $MERGED<br><br> </b>               
                    그리고 다음에 conflict가 발생했을 때, 아래 명령어를 입력하면 VScode가 열리고, 그 안에서 conflict를 해결할 수 있다.<br>
                    -> <b>git mergetool</b><br><br>
                    VScode 말고 다른 mergetool은 P4Merge가 있다.</p>
            </ul><hr><br>
        <p style = "font-size : x-large">13. Jenkins</p><hr>
            <ul>
                <li><b>젠킨스란?</b>
                    <p>모든 언어의 조합 소스 코드 레포지토리에 대한 지속적인 통합(Continuous integration, CI)과 지속적 배포(continuous delivery, CD)환경을 구축하기 위한 도구. 빌드, 테스트, 배포 프로세스를<br>
                    자동하여 소프트웨어 품질과 개발 생산성을 높일 수 있다.</p>
                <li><b>젠킨스 장점</b><br><br>
                    <ul>
                        <li><b>편리한 설정</b><br><br>
                            <ul>
                                <li>웹 기간의 콘솔로 다양한 인증 기반과 결합이 가능하며 권한 관리 기능을 통해 안전한 빌드/배포 환경을 구축할 수 있다.<br><br>
                                <li>빌드/배포의 결과에 대한 통지 받을 수 있는 설정이 간편하고 다양한 채널을 통해 빠르게 피드백을 받을 수 있다.<br><br>         
                                <li>수많은 플러그인을 사용하여 자동화 할 수 있어 반복되는 작업을 줄일 수 있다.<br><br>
                            </ul>
                        <li><b>안정적인 빌드/배포 환경</b><br><br>
                            <ul>
                                <li>소스 버전 관리 툴과 연동하여 코드 변경을 감지하고, 자동화 테스트를 포함한 빌드를 수행하여 소프트웨어 품질을 향상시킬 수 있다.<br><br>
                                <li>자동화 테스트에는 코딩 표준 준수 여부 체크, 유닛 테스트, 통합 테스트 등을 설정할 수 있고 테스트 결과에 대한 피드백을 받아 잠재적인 오류를 사전에 예방할 수 있다.<br><br>
                                <li>빌드 결과물을 지속적으로 배포하도록 설정하여 개발 프로세스 전체를 자동화할 수 있다.<br><br>
                            </ul>
                        <li><b>다양한 활용 및 손쉬운 확장</b><br><br>
                            <ul>
                                <li>젠킨스는 많이 사용 되고 있는 오픈 소스 소프트웨어로 문서화가 잘 되어 있다. 빌드/배포 이외에도 스케쥴링을 이용한 배치 작업에도 활용되는 등 다양한 적용 사례들을 참고할 수 있다.<br><br>
                                <li>플러그 인을 직접 개발하여 기능을 확장하는 것도 가능하다.<br><br>
                            </ul>
                    </ul>
                <li><b>젠킨스 기능</b>
                    <p>젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방법이 일반적이였는데, 젠킨스는 서브버전, git과 같은 버전 관리 시스템과  연동해서 소스의 커밋을 자동적으로<br>
                    자동화 테스트가 포함된 빌드가 작동하도록 도와주게 되어 편의성이 증가되었다.<br><br>
                    이러한 기능을 수행하는 젠킨스는 컴파일 오류를 검출하고, 자동화 테스트를 수행하며, 정적 코드 분석으로 인한 코딩 규약 준수 여부를 체크하고 프로파일링 툴을 이용한 성능 변화 감시<br>
                    결합 테스트 환경에 대한 배포 작업의 큰 도움을 준다.</p>
            </ul><hr><br>
        <p style = "font-size : x-large">14. On-premise와 Off-premise</p><hr>
            <ul>
                <li><b>On-premise</b>
                    <p>온 프레미스란 서버를 클라우드 환경 등 원격 환경이 아닌 사내 전산실 서버 등에 직접 설치해 운영하는 방식이다.<br><br>
                    현재 IT 산업내에선 클라우드 기술이 많이 발전되어 Azure, AWS등 여러 클라우드 서버를 사용하는 기업들이 늘고있다. 이러한 클라우드 서버가 사용화 되기 이전<br>
                    일반적으로 사용되던 방식이 On-premise방식이었다.<br><br>
                    온 프레미스의 장점은 정보 보안성이 높지만, 시스템 구축에 많은 비용과 시간이 걸린다는 단점이 있다.</p>
                <li><b>Off-premise</b>
                    <p>온 프레미스와 상반된 의미로 서버 구성을 클라우드 시스템을 이용해 구죽하는 것을 말한다.<br><br>
                    Off-premise의 경우 On-premise에 비해 구축이 쉽고 간편하다는 장점이 있다. 그러나 문제 발생 시 트러블 슈팅이 어려울 수 있다는 단점을 가지고 있다.<br><br>
                    현재 IT산업에서는 On-premise, Off-premise 어느 하나만 사용하기 보단, 보안적으로 중요한 서비스 및 데이터 등은 On-premise환경에 구성하고, 그외 환경은 퍼블릭 클라우드<br>
                    즉, Off-premise환경에 구성하는 방식이 대세를 이루고 있다.</p>
            </ul><hr><br>
        <p style = "font-size : x-large">15. rm -rf와 위험성</p><hr>
            <ul>
                <li><b>rm -rf</b>
                    <p>리눅스에서 rm은 파일을 삭제하는 명령어이다. 기본형인 rm만 단독으로 사용하면 파일만을 제거하고 디렉토리(폴더)는 제거할 수 없다.<br><br>
                    rm에 -r 옵션이 붙으면 디렉토리를 통째로 삭제할 수 있는 동시에 하위 디렉토리까지 모두 삭제가 가능하다.<br><br>
                    -f옵션이 붙으면 쓰기 권한없이 읽기 권한만 있는 파일도 강제 삭제한다. 지정한 삭제 대상이 없는 경우 메시지를 출력하지 않도록 한다.<br><br>
                    결론적으로 rm -rf는 폴더 삭제가 가능하고, 삭제할 때마다 일일이 물음에 대답하지 않아도 되는 편리한 삭제 명령어이다. 그렇기에 가장 많이 사용되는 동시에 갖아 위험한 명령어이기도 하다.</p>
                <li><b>rm -rf 명령어 대형사고의 주범은?</b>
                    <p>rm -rf로 인한 대형사고의 주범은 /라고 볼 수 있다. 아래 세 명령어의 차이를 보면 이해가 된다.</p>
                    <ul>
                        <li><b>rm -rf ./*</b><br><br>
                        <li><b>rm -rf /*</b><br><br>
                        <li><b>rm -rf . /*</b><br><br>
                        </li>
                    </ul>
                    <p>점(.)하나 차이이지만 꽤나 무시무시한 차이가 발생한다. 첫 번째 명령어는 현재 있는 위치를 기준을 하위 디렉토리를 모두 삭제한다. 이 명령어를 사용하려다가 아래의 명령어를 사용하면 사고가 발생한다.<br>
                    두 번째는 / 디렉토리 및 하위 디렉토리를 모두 삭제하는 명령어, 세 번째는 현재 디렉토리(.)와 / 디렉토리 및 하위 디렉토리를 모두 삭제하는 명령어이다.<br>
                    쉽게 말하자면 root 계정으로 이 명령어를 수행하면 하드디스크를 포함한 OS를 깨끗하게 밀어버린다. 말 그대로 대형사고가 발생한 것이다.</p>
                <li>대형사고 예방법</li>
                    <ul>
                        <li><b>/를 되도록 쓰지 않는다.</b>
                            <p>rm -rf로 인한 사고를 예방하려면 절대경로의 시작인 /를 사용하지 않는게 좋다. 삭제하려는 위치로 이동하면 /없이도 *를 이용하면 전체 삭제가 가능하다.<br>
                            -> <b>rm -rf *</b></p>
                        <li><b>확장자를 패턴으로 사용한다.</b>
                            <p>확장자를 붙여서 삭제하는 습관을 들이면 좋다. 예를 들어 로그 파일을 모두 정리하는 경우에는 *.log 패턴으로 삭제하는 방법이다. 로그 정리할 때 매우 유용하다.<br>
                            -> <b>rm -rf *.log</b></p>
                        <li><b>-i옵션을 활용한다.</b>
                            <p>귀찮은 방법이라 실용성에는 의문이 있지만 파일을 삭제할 때 "삭제하시겠습니까?"같은 대답에 Y나 N으로 답하도록 -i 옵션을 사용할 수 있다.<br>
                            -> <b>rm -i a.txt</b></p>
                        <li><b>root 계정에서는 가급적 rm -rf 사용을 하지 않는다.</b>
                            <p>가능한 루트 계정으로는 rm -rf를 쓰지 않는게 좋다. 모든 권한이 잇기 때문에 실수했을 경우 더 치명적이기 때문이다.</p>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">16. 파일 사용자와 그룹</p><hr>
            <ul>
                <li><b>파일 사용자(소유자)</b> : 소유자란 '해당 파일을 소유한 사람'을 말한다. 그리고 리눅스에서는 처음에 파일을 만든 사람이다.<br><br>
                <li><b>그룹</b> : 그룹이란 '해당 파일을 사용할 수 있는 그룹'을 말한다. 그리고 리눅스에서는 처음에 파일을 만든 사람이 속한 메인 그룹이다.<br><br>
                <li><b>chown 명령어</b>
                    <p>chown 명령어는 소유자또는 소유 그룹을 변경하는 명령어이다.<br>
                    -> <b>chown [옵션][소유자 : 그룹][파일]</b></p>
                    <p>- chown 명령어 옵션</p>
                    <ul>
                        <li><b>-c, --changes</b> : 파일 소유가 변경된 정보를 출력한다.<br><br>
                        <li><b>--dereference</b> : 심볼릭 링크는 소유변경을 하지 않는다. (기본 옵션)<br><br>
                        <li><b>h, no--dereference</b> : 심볼릭 링크도 소유를 변경한다.<br><br>
                        <li><b>--from=CURRENT_OWNER:CURRENT_GROUP</b> : 소유자와 그룹이 각각 CURRENT_OWNER과 CURRENT_GROUP와 일치하는 파일에 대해서만 소유를 변경한다.<br><br>
                        <li><b>--no-preserve-root</b> :'/'를 처리한다.<br><br>
                        <li><b>--preserve-root</b> : '/'를 처리한다.<br><br>
                        <li><b>-f, silent, quite</b> : 에러메시지를 출력하지 않는다.<br><br>
                        <li><b>-R, --recursive</b> : 파일과 디렉토리에 재귀적용한다.<br><br>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">17. GitLab</p><hr>
            <ul>
                <li><b>GitLab이란?</b>
                    <p>소프트웨어 개발 및 협업을 위한 올인원 솔루션을 제공하는 웹 기반 DevOps 플랫폼이다.<br><br>
                    팀이 소프트웨어 프로젝트를 보다 효율적으로 계획, 생성, 구축, 테스트 및 배포하는데 도움이 되는 다양한 도구와 기능을 제공한다.</p>
                <li><b>GitLab 특징</b><br><br>
                    <ul>
                        <li><b>설치형 버전관리 시스템</b>
                            <p>자신의 서버에 직접 설치해서 사용할 수 있다.</p>
                        <li><b>클라우드 버전 관리 시스템</b>
                            <p>gitlab.com을 이용하면 서버 없이도 GitLab의 기능을 이용할 수 있다.</p>
                        <li><b>Issue Tracker 제공</b>
                            <p>Issue Tracker란 프로젝트를 진행하는 과정에서 발생하는 업무를 관리해주는 업무 관리 시스템</p>
                        <li>Git 원격 저장소 제공<br><br>
                        <li>API를 제공하여 사용자의 어플리케이션에서 활용할 수 있다.<br><br>
                        <li>Team, Group 기능을 제공하여 저장소를 더욱 효율적으로 관리할 수 있도록 하였다.<br><br>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">18. Slack</p><hr>
            <ul>
                <li><b>Slack이란?</b>
                    <p>팀과 업무를 하나로 이어주는 단일 플랫폼이다. 업무에 관련된 모든 커뮤니케이션을 Slack에서 처리할 수 있고, 그에 따라 빠른 업무 확인 및 의사 결정이 가능해 이메일을 대체할 수 있는 업무 협업 툴이다.</p>
                </li><b>Slack 장점</b>
                    <ul>
                        <li><b>이메일보다 더 안전하다.</b>
                            <ul>
                                <li>이메일과 달리 데이터 침해의 90%를 야기하는 스탬이나 피싱에 취약하지 않다.
                                <li>소속 조직의 사람 또는 Slack Connect를 사용하는 신뢰할 수 있는 파트너로 부터만 Slack의 메세지를 받게 된다.
                                <li>엔터프라이즈급 데이터 보호 및 개인정보 보호를 제공한다.
                            </ul>
                        <li><b>이메일보다 편하다.</b>
                            <ul>
                                <li>만약 이메일을 사용하면 받은 편지함에서 특정 프로젝트의 대화를 보기 위해 일일히 검색해야하지만 Slack에서는 모든 대화와 파일을 한 채널에서 확인할 수 있어 시간이 절약된다.
                            </ul>
                        <li><b>실시간 대화가 가능하다.</b>
                            <ul>
                                <li>Slack에서는 모든 팀원이나 팀과 실시간으로 대화할 수 있다.
                                <li>중요도 파악이 힘든 이메일과 달리, Slack에서는 빠른 응답이 필요한 사람에게 알림을 보낼 수 있기 때문에 답변을 빠르게 받을 수 있다.
                             </ul>  
                        <li><b>모든 정보를 한눈에 확인할 수 있다.</b>
                            <ul>
                                <li>하나의 채널에서 모든 사용자가 동일한 내용을 확일할 수 있으므로, 책임자 및 업무 진행 방법을 쉽게 알 수 있다.
                            </ul>  
                    </ul>
                <li><b>채널?</b>
                    <p>Slack은 특정 프로젝트에 대한 모든 대화 및 파일을 채널을 통해 확인이 가능하다. 모든 프로젝트와 주제, 팀별로 채널을 만들 수 있기 때문에 업무를 더 체계적이고 명확하게 할 수 있다.<br>
                    또한 채널을 통해 작업 상황을 언제든지 팀과 공유할 수도 있다.<br>
                    채널은 공개 및 비공개로 설정 가능하고, Slack Connect를 이용해 외부 여러 조직과 협업도 가능하다.</p>
                <li><b>다이렉트 메세지</b>
                    <p>채널 아래에 다이렉트 메세지를 확인할 수 있다. 다이렉트 메세지는 인스타그램 DM등의 메신저와 같다. 채널 외부에서 진행하는 소규모 대화인데 전체 채널이 필요하지 않은 일회성 대화에 적합하다.<br>
                    또한 자기 자신에게도 메세지를 보낼 수 있는데 스스로에게 보낸 메세지는 본인만 확인 할 수 있다.</p>
            </ul><hr><br>
        <p style = "font-size : x-large">19. Kafka</p><hr>
            <ul>
                <li><b>카프카란?</b>
                    <p>카프카는 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위해 설계된 고성능 분산 이벤트 스트리밍 플랫폼이다.<br><br>
                        Pub-Sub 모델의 메세지 큐 형태로 동작하며 분산환경에 특화되어 있다.</p>
                <li><b>메세지 큐란?</b>
                    <p>메세지 큐는 메시지 지향 미들웨어를 구현한 시스템을 프로그램 간의 데이터를 교환할 때 사용하는 기술이다.</p>
                <li><b>카프카 구성요소 및 동작원리</b><br><br>
                    <ul>
                        <li><b>구성요소</b><br><br>
                            <ul>
                                <li><b>Event</b> : Kafka에 producer와 consumer가 데이터르 주고 받는 단위<br><br>
                                <li><b>Producer</b> : Kafka에 이벤트를 게시(post, pop)하는 클라이언트 어플리케이션<br><br>
                                <li><b>Consumer</b> : Topic을 구독하고 이로부터 얻어낸 이벤트를 받아 처리하는 클라이언트 어플리케이션<br><br>
                                <li><b>Topic</b> : 이벤트가 모이는 곳. producer는 topic에 이벤트를 게시하고, consumer는 topic을 구독해 이로부터 이벤트를 가져와 처리<br><br> 
                                <li><b>Partition</b> : topic은 여러 broker에 분산되어 저장되며, 이렇게 분산된 topic을 partition이라 한다.<br><br> 
                                <li><b>Zoopeeper</b> : 분산 메세지 큐의 정보를 관리<br><br> 
                            </ul>
                        <li><b>동작원리</b><br><br>
                            <ul>
                                <ol type="1">
                                    <li>publisher는 전달하고자 하는 메세지를 topic을 통해 카테고리화 한다.<br><br>
                                    <li>subscriber는 원하는 topic을 구독함으로써 메세지를 읽어온다.<br><br>
                                    <li>publisher와 subscriber는 오로지 topic 정보만 알 뿐, 서로에 대해 알지 못한다.<br><br>
                                    <li>Kafka는 broker들이 하나의 클러스터로 구성되어 동작하도록 설계<br><br>
                                    <li>클러스터 내 broker에 대한 분산처리는 Zoopeeper가 담당한다.<br><br>
                                </ol>
                            </ul>
                    </ul>
                <li><b>장점</b><br><br>
                    <ul>
                        <li>대규모 트래픽 처리 및 분산 처리에 효과적<br><br>
                        <li>클러스터 구성, Fail-over, Replication 같은 기능이 있다.<br><br>
                        <li>100Kb/sec정도의 속도 (다른 메세지 큐보다 빠르다)<br><br>
                        <li>디스크에 메세지를 특정 보관 주기동안 저장하여 데이터의 영속성이 보장되고 유실위험이 적다. 또한 Consumer 장애 시 재처리가 가능하다.<br><br>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">20. Prometheus</p><hr>
            <ul>
                <li><b>프로메테우스란?</b>
                    <p>메트릭 수집, 시각화, 알림, 서비스 디스커버리 기능을 모두 제공하는 오픈 소스 모니터링 시스템이다.</p>                   
                </li><b>프로메테우스 특징</b><br><br>
                    <ul>
                        <li>Pull 방식의 메트릭 수집, 시계열 데이터 저장<br><br>
                        <li>PromQL을 활용하여 저장된 시계열 쿼리 및 집계<br><br>
                        <li>서비스 디스커버리<br><br>
                    </ul>
                <li><b>프로메테우스 구조</b><br><br>
                    <ul>
                        <li><b>Prometheus Server</b><br><br>
                            <ul>
                                <li>시계열 데이터를 생성하고 저장하는 핵심 서비스<br><br>
                                <li>Retrieval
                                    <p>- 서비스 디스커버리로부터 모니터링 대상을 받아오고 Exporter로부터 주기적으로 그 대상의 메트릭을 수집하는 모듈</p>
                                <li>TSDB
                                    <p>- 시계열 데이터를 저장하는 자체 스토리지 엔진, 외부에 DB를 두는 것이 아니면 프로메테우스는 로컬에 데이터를 저장해둔다.</p>
                                <li>HTTP Server
                                    <p>- 통신할 때 사용하는 HTTP Server</p>
                            </ul>
                        <li><b>Alertmanager</b>
                            <p>특정 메트릭이 임계치를 넘어가거나 경계에 잡혔을 때 이메일, 슬랙 등을 통해 알림 전송 가능</p>
                        <li><b>Data Visualization</b><br><br>
                            <ul>
                                <li>프로메테우스 자체 web UI가 있어 데이터 시각화가 가능<br>
                                    - 시각화 기능은 약한 편이라 보통 Grafana라는 대시보드 툴로 대체해서 사용하는 편이다.<br><br>
                                <li>PromQL이라는 쿼리를 사용해서 데이터 조회<br><br>
                            </ul>
                        <li><b>Service Discovery</b><br><br>
                            <ul>
                                <li>서비스 디스커버리란 MSA같은 분산 환경에서 서비스 클라이언트가 서비스를 호출할 때 서비스의 위치를 알아낼 수 있는 기능<br><br>
                                <li>프로메테우스는 서비스 디스커버리기능을 지원함 (쿠버네티스 등등)<br><br>
                                <li>쿠버네티스에 존재하는 모든 노드와 팟의 메트릭을 수집 가능<br><br>
                            </ul>
                        <li><b>Exporter</b><br><br>
                            <ul>
                                <li>타겟 시스템에서 메트릭을 읽어서 프로메테우스가 풀링 할 수 있도록 하는 모니터링 에이전트<br><br>
                                <li>데이터를 가져오고 싶은 시스템에 설치하는 프로그램<br><br>
                            </ul>
                        <li><b>Pushgateway</b><br><br>
                            <ul>
                                <li>프로메테우스가 메트릭을 푸시할 수 있게 지원<br><br>
                                <li>푸시된 메트릭을 프로메테우스에서 가져갈 수 있도록 중재자 역할 수행<br><br>
                            </ul>
                   </ul>
                <li><b>프로메테우스 장단점</b><br><br>
                   <ul>
                        <li><b>장점</b><br><br>
                            <ul>
                                <li>Pull 방식의 구조를 채택해서 모든 메트릭 정보를 중앙 서버로 보내지 않아도 됨<br><br>
                                <li>다양한 써드파티 프로그램과 연동을 통해 운영이 쉬움<br><br>
                                <li>구조가 복잡하지 않고 간단<br><br>
                                <li>모든 데이터를 수집하지 않고 일정 주기로 메트릭을 수집해 애플리케이션에 무리가 없음<br><br>
                            </ul>
                        <li><b>단점</b><br><br>
                            <ul>
                                <li>클러스터링이 불가능<br><br>
                                    - 스케일을 키우고 싶으면 프로메테우스를 여러개 구축해 계층형으로 연결해야 함<br><br>
                                <li>모든 데이터를 수집하지 않아서 대략적인 데이터 흐름을 보긴 좋지만 모든 데이터를 필요로하는 목적에는 부적합<br><br>
                                    - APM(Application Performance Monitoring)같이 모든 로그를 추적해야하는 상황에는 좋지 않음<br><br>
                                    - Pulling하는 그 순간의 스냅샷 정보만 알 수 있음                  
                            </ul>
                   </ul>
            </ul><hr><br>
    </body>
</html>