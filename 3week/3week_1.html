<heml>
    <head>
        <title>3week_1 Assignment</title>
    </head>
    <body>
        <p style = "font-size : x-large">1. GO 언어</p><hr>
            <ul>
                <li><b>GO언어 란?</b>
                    <p>Google에서 만든 프로그래밍 언어로 C를 기반으로 만들어 졌으며, C언어의 장점을 살리면서 다양한 곳에서 활용할 수 있도록 만든 언어이다.<br>
                    즉, 시스템 개발, 운영체제, 웹 서버, 웹 브라우저, 로봇, 검색엔진 등 다양한 곳에서 사용하도록 만들어졌다.</p>
                <li><b>GO언어 특징</b><br><br>
                    <ul>
                        <li><b>개발 속도가 빠르다</b>
                            <p>Go언어는 멀티코어 기반으로 설계되어 있기 때문에 현재 하드웨어 개발, 소프트웨어 개발에 큰 이점을 갖고있다.<br>
                            또한, C/C++에서의 컴파일 시간보다 GO언어가 더 빠르다. 그 이유는 모듈화를 위한 의존성 때문이다.</p>
                        <li><b>모듈화를 위한 의존성</b>
                            <p>C++을 예를 들어 보자면 라이브러리가 다른 라이브러리르 참조하는 경우가 많다.<br>
                                때문에 빌드를 할 때 동적 라이브러리 DLL(Dynamic Link Library)나 정적 라이브러리 LIB(STL, stdio.h, iostream 등..)을 사용하는데<br>                              
                                이때 각 라이브러리들은 의존성을 띄고 있으며, 라이브러리의 기능중 하나를 사용하려면 전체 라이브러리를 컴파일 시켜야 한다.<br>                       
                                그러면 라이브러리가 많을수록 컴파일 시간이 늘어나며 생산성이 떨어지게 된다.<br>                               
                                하지만 Go언어는 모듈화를 통해 의존성을 유지하고 있기 때문에 사용자가 필요한 부분만 빼서 쓸 수 있다는 장점이 있다.</p>
                        <li><b>동적 타입을 가진 속성 언어</b>
                            <p>Go언어는 정적 타입 언어와 동적 타입 언어를 동시에 지원하기 때문에 컴파일 타임에서 에러를 찾을 수 있다.</p>
                        <li><b>가비지 컬렉션</b>
                            <p>C/C++에서 없는 가비지 컬렉션을 Go언어에서 제공한다. 때문에 사용자는 동적 메모리 할당과 해제에 대한 고민을 하지 않아도 된다.<br>
                                또한 JVM의 가비지 컬렉션과의 차이는 Java Code가 JVM에서 실행되게 되면 JVM내에서 메모리를 관리해주게 된다.<br>                              
                                하지만 Go언어는 실행파일 내에 가비지 컬렉션이 있기 때문에 좀 더 좋은 퍼포먼스를 낸다고 할 수 있다.</p>
                        <li><b>병렬처리</b>
                            <p>Go언어는 멀티코어를 기반으로 만들어진 언어다. 때문에 병렬처리 하는데 있어서 많은 도움을 주고 있다.
                                즉, C/C++보다 더 안전하고 편안한 개발을 할 수 있는것이 Go언어이다.</p>
                    </ul>
                <li><b>goroutine</b>
                    <p>Go 언어는 Thread라는 개념 대신 goroutine이라는 개념을 사용한다.<br>
                        해당 goroutine은 Thread보다 가벼운 개념이며, 데이터를 주고받을 때 공유 메모리를 사용하지 않고 채널이라는 개념을 도입해 채널을 통해 데이터를 주고 받는다고 한다.<br>
                        또한 멀티플렉싱 방식으로 운영체제의 도움 없이 내부적으로 동시성 있게 돌기 때문에, context에 대한 부담이 적다고 한다.</p>
            </ul><hr><br>
        <p style = "font-size : x-large">2. RUST 언어</p><hr>
            <ul>
                <li><b>RUST언어 란?</b>
                    <p>Rust는 Mozilla에서 개발한 시스템 프로그래밍 언어이다. 안전성, 속도, 병행성을 강조하는 언어로 메모리 안정성을 보장하기 위해 컴파일러에서 오류검사를 수행한다.<br>
                    이로 인해 개발자가 메모리 누수, 버퍼 오버런, null 포인터 역참조등의 문제로 부터 보다 적은 수고를 들인다. 또한 다양한 병행성 모델을 지원하여 병행 프로그래밍을 쉽게 할 수 있다.<br><br>
                    Rust는 많은 개발자들이 사용하는 패키지 매니저인 Cargo를 제공하며, 이를 통해 의존성 관리와 빌드 시스템을 손쉽게 처리할 수 있다.</p>
                <li><b>RUST 장점</b><br><br>
                    <ul>
                        <li><b>메모리 안정성</b>
                            <p>소유권 모델 및 차용 시스템은 메모리가 안전하고 효율적인 방식으로 관리되도록 보장하여 널 포인터 및 버터 오버플로와 같은 일반적인 메모리 관련 버그를 방지한다.</p>
                        <li><b>고성능</b>
                            <p>구문 및 저수준 제어는 효율적인 메모리 사용을 허용하므로 시스템 프로그래밍 및 게임 개발과 같은 성능이 중요한 작업에 적합하다.</p>
                        <li><b>교차 플렛폼 지원</b>
                            <p>Rust의 컴파일러는 다양한 플랫폼을 대상으로 할 수 있으므로 여러 운영체제에서 소프트웨어를 개발하기 위한 다재다능한 선택이다.</p>
                        <li><b>동시성 지원</b>
                            <p>동시성 및 병렬성에 대한 Rust의 기본 제공 지원은 데이터 경합 또는 교착 상채의 위험없이 다중 스레드 프로그램을 쉽게 작성할 수 있도록 한다.</p>
                        <li><b>대규모 커뮤니티 및 생태계</b>
                            <p>성장하는 개발자 커뮤니티가 있으며, 그 결과 Rust 애플리케이션을 쉽게 개발할 수 있는 라이브러리 및 도구의 대규모 생태계가 성장했다.</p>
                    </ul>
                <li><b>RUST 단점</b><br><br>
                    <ul>
                        <li><b>가파른 학습 곡선</b>
                            <p>구문 및 소유권 모델은 저수준 프로그래밍에 익숙하지 않은 개발자에게 어려울 수 있다.</p>
                        <li><b>느린 컴파일 시간</b>
                            <p>컴파일러는 큰 코드베이스를 컴파일할 때 느려질 수 있으므로 개발 프로세스가 더 느리고 덜 효율적이다.</p>
                        <li><b>소규모 인재 풀</b>
                            <p>비교적 새로운 언어라 전문지식을 갖춘 개발자를 찾는 것이 어려울 수 있다.</p>
                        <li><b>제한된 라이브러리 지원</b>
                            <p>생태계는 성장하고 있지만 다른 프로그래밍 언어에서 사용할 수 있는 성숙하고 안정적인 일부 라이브러리가 여전히 부족하다.</p>
                        <li><b>제한된 도구 지원</b>
                            <p>상대적으로 새롭기 때문에 기존 언어보다 사용할 수 있는 도구가 적어 좋은 디버깅 및 프로파일링 도구를 찾기가 더 어렵다.</p>
                    </ul>
                <li><b>RUST가 사용되는 곳</b>
                    <p>RUST는 안정성, 성능, 병행성 및 확장성을 강조하는 시스템 프로그래밍 언어로, 다양한 분야에서 사용된다.</p>
                    <ul>
                        <li><b>시스템 프로그래밍</b>
                            <p>RUST는 운영체제, 네트워크 스택, 임베디드 시스템, 게임 엔진, 웹 브라우저 및 다른 시스템 소프트웨어를 개발하는데 사용된다.</p>
                        <li><b>웹 어셈블리</b>
                            <p>웹 어셈블리(웹 브라우저에서 실행되는 고성능 바이너리 코드)를 작성하는데 사용된다. 이를 통해 웹 애플리케이션의 성능을 향상시키고, 게임이나 3D 그래픽과 같은 고성능 웹 애플리케이션을 작성할 수 있다.</p>
                        <li><b>블록체인</b>
                            <p>블록체인 구현을 위해 사용되기도 한다. 예를 들면 Polkadot은 Rust로 구현된 블록체인 프로토콜이다.</p>
                        <li><b>시뮬레이션</b>
                            <p>과학 및 엔지니어링 분야에서 시뮬레이션 및 계산 작업을 수행하는데 사용되기도 한다.</p>
                        <li><b>도구 및 라이브러리</b>
                            <p>다양한 도구 및 라이브러리를 제공한다. RUST는 다양한 오픈 소스 라이브러리, 프레임워크 및 도구를 가지고 있다.</p>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">3. gdb</p><hr>
            <ul>
                <li><b>gdb란?</b>
                    <p>gdb는 GNU DeBugger의 약자로 GNU 소프트웨어를 위한 기본 디버거라는 의미이다.<br>
                    gdb가 지원하는 언어는 다양하다<br>
                    Ada, Assembly, C, C++, D, Fortran, Go, Objective-C, Modula-2, Pascal, Rust</p>
                <li><b>설치 방법</b>
                    <p>매우 간단한 방법으로 설치가 가능하다.<br>
                    - <b>sudo apt install gdb</b></p>
                <li><b>명령어</b><br><br>
                    <ul>
                        <li><b>list</b>
                            <p>현재 위치에서 소스 파일의 내용을 10줄 보여줌</p>
                        <li><b>run</b>
                            <p>프로그램 시작 / break가 있다면 break까지 실행<br>
                            - run arg : 새로운 인수를 가지고 프로그램 시작</p>
                        <li><b>break</b>
                            <p>특정 라인이나 함수에 중지점을 설정<br>
                            - break function : 현재 파일 안의 함수 function에 정지 설정<br>
                            - break file function : 파일 file안의 function에 중지 설정<br>
                            - watch : 감시점 설정<br>
                            - until : 실행 중 line까지 실행</p>
                        <li><b>clear</b>
                            <p>특정 라인이나 함수에 있던 중지점 삭제</p>
                        <li><b>delete</b>
                            <p>몇몇 정지점이나 자동으로 출력되는 표현 삭제</p>
                        <li><b>next</b>
                            <p>다음 행을 수행. 서브루틴을 호출하면서 계속 수행<br>
                            - next n : n번 수행</p>
                        <li><b>step</b>
                            <p>한줄씩 실행. 함수를 포함하고 있으면 함수 내부로 들어가서 한줄씩 실행</p>
                        <li><b>print</b>
                            <p>- print expr : 수식의 값을 보여줌</p>
                        <li><b>display</b>
                            <p>현재 display된 명령의 목록을 보여줌</p>
                        <li><b>bt</b>
                            <p>프로그램 스택을 보여줌(backtrace)</p>
                        <li><b>kill</b>
                            <p>디버깅 중인 프로그램의 실행 취소</p>
                        <li><b>file</b>
                            <p>- file program : 디버깅할 프로그램으로서 파일을 사용</p>
                        <li><b>cont</b>
                            <p>- continue : 현재 위치에서 프로그램을 계속 실행</p>
                        <li><b>quit</b>
                            <p>gdb에서 빠져나감</p>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">4. gcc의 컴파일 과정</p><hr>
            <ul>
                <ol type = '1'>
                    <li><b>전처리 단계</b>
                        <p>소스파일=file.c -> (전처리=cpp) -> 전처리된 파일=file.i<br>
                            전처리기(cpp) = gcc 의 가장 먼저 작동됨, cpp는 소스 파일의 #include #define으로 시작되는 전처리기 부분을 처리<br>                      
                            필요한 헤더파일을 삽입하고 실행 문장의 매크로를 상수로 변환 file.i를 임시 파일을 생성함</p>
                    <li><b>컴파일 단계</b>
                        <p>전처리된 파일=file.i -> (컴파일=cc1) -> 어셈블리어 파일=file.s<br>
                            컴파일(cc1) = 컴파일러가 전처리된 파일(file.i)로 부터 어셈블리어로 된 파일(file.s)을 생성, 이것 역시 임시적으로 만들어짐</p>
                    <li><b>어셈블 단계</b>
                        <p>어셈블리어 파일=file.s -> (어셈블=as) -> 오브젝트 파일=file.o<br>
                            어셈블(as) = 어셈블리어 된 파일 (file.s)을 기계어로 된 파일(file.o)로 변환</p>
                    <li><b>링크 단계</b>
                        <p>오브젝트 파일=file.o -> (링크=ld) -> 실행파일=a.out<br>
                            링크(ld) = 오브젝트 파일은 printf,scanf 와 같은 라이브러리 함수에 해당하는 코득가 없기 때문에 실행될 수 없다. 또한 여려 파일로 이루어진<br>
                            프로그램의 경우에도 파일간에 연결이 지지 않아 실행될 수 없는데 라이브러리 함수와 오브젝트 파일들을 연결해 실행 파일을 생성하는 단계</p>
                </ol>
            </ul><hr><br>
        <p style = "font-size : x-large">5. 파일 리버싱</p><hr>
            <ul>
                <li><b>리버싱이란?</b>
                    <p>소프트웨어 분야에서 해당 프로그램의 구조, 기능, 동작 등의 원리를 역으로 따라가며 이해하고 분석하여 부족한 부분이 있거나 추가 되었으면 하는 새로운 기능 등을 추가하는 전체적인 행위이다.</p>
                    <ul>
                        <li><b>리버스 엔지니어링(Reverse Engineering)</b>
                            <p>일반적인 의미에서는 '역공학'이라고 하며 어느 특정 물건, 장치 등이 있으면 그것에 대한 구조, 기능, 동작 등을 역으로 따라가며 분석하고 그 원리를 이해하여 부족한 부분을 보안하며 새로운 기능을 추가하는 작업</p>
                        <li><b>리버스 코드 엔지니어링(Reverse Code Engineering)</b>
                            <p>RCE(Reverse Code Engineering)는 소프트웨어 분야의 리버스 엔지니어링 이라고 생각하면 된다.</p>
                    </ul>
                <li><b>리버싱 방법</b><br><br>
                    <ul>
                        <li><b>정적분석</b>
                            <p>파일의 겉모습을 관찰하여 분석하는 방법이다. 파일을 실행하지 않고 파일의 종류, 크기, 헤더정보, 실행 압축 여부, 등록 정보, 디지털 인증서 등의 내용을 확인하는 것이다.<br>
                            또한 디스어셈블러를 이용해서 내부코드와 그 구조를 확인하는 방법이다.</p>
                        <li><b>동적방법</b>
                            <p>파일을 직접 실행시켜서 그 행위를 분석하고, 디버깅을 통해 코드의 흐름과 메모리의 상태 등을 자세히 살펴보는 방법이다.<br>
                            레지스트리, 네트워크 등을 관찰하면서 프로그램의 행위를 분석하고 디버거를 이용하여 프로그램 내부 구조와 동작 원리를 분석하기도 한다.</p>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">6. 직렬화와 역직렬화</p><hr>
            <ul>
                <li><b>직렬화란?</b>
                    <p>말그대로 객체를 직렬화하여 전송 가능한 형태로 만드는 것을 의미한다. 객체들의 데이터를 연속적인 데이터로 변형하여 Stream을 통해 데이터를 읽도록 해준다.<br>
                    이것은 주로 객체들을 통째로 파일로 저장하거나 전송하고 싶을 때 주로 사용된다.</p>
                <li><b>역직렬화란?</b>
                    <p>직렬화된 파일 등을 역으로 직렬화하여 다시 객체의 형태로 만드는 것을 의미한다. 저장된 파일을 읽거나 전송된 스트림 데이터를 읽어 원래 객체의 형태로 복원한다.</p>
            </ul>
        <hr><br>
        <p style = "font-size : x-large">7. 웹 서버</p><hr>
            <ul>
                <li><b>웹 서버란?</b></li>
                    <p>- 웹 서버란 두가지 측면으로 구분할 수 있다.</p>
                    <ul>
                        <li><b>웹 서버(하드웨어)</b><br><br>
                            <ul>
                                <li>웹 사이트의 컴포넌트 파일들을 저장하는 컴퓨터<br><br>
                                <li>컴포넌트 파일에는 HTML, Images, CSS, JavaScript가 존재<br><br>
                                <li>컴포넌트 파일을 인터넷을 통해 클라이언트에 전달<br><br>
                            </ul>
                        <li><b>웹 서버(소프트웨어)</b><br><br>
                            <ul>
                                <li>사용자가 어떻게 호스트 파일들에 접근하는지 관리<br><br>
                                <li>웹 서버는 주소 HTTP 프로토콜을 사용하여 클라이언트의 요청을 처리 및 응답<br><br>
                            </ul>
                    </ul>
                <li><b>웹 서버 특징/기능</b></li>
                    <p>웹 서버의 주요 목적은 웹 페이지를 클라이언트로 전달하는 것이다. 주로 이미지, CSS, JS 등을 포함한 HTML 문서가 클라이언트로 전달된다.<br><br>
                        흔히 웹 브라우저 또는 웹 크롤러로 부르는 클라이언트는 HTTP를 통해 리소스를 요청하며 서버는 해당 리소스를 반환하거나 처리할 수 없을 경우 에러 메시지를 전달한다.<br>
                        이러한 리소스는 일반적으로 서버의 보조 기억 장치에 있는 실제 파일을 가리키지만 반드시 그런 것은 아니며 웹 서버가 어떻게 수행하느냐에 따라 달라질 수 있다.<br>                    
                        주된 기능은 콘텐츠를 제공하는 것이지만 클라이언트로부터 콘텐츠를 전달 받는 것도 웹 서버의 기능에 속한다. 이러한 기능은 파일 업로드를 포함하여 클라이언트에서 제출한 웹 폼을 수신하기 위해 사용된다.<br><br>                                                       
                        보통 대다수의 웹 서버는 Active Server Page(ASP), PHP 등의 서버 사이드 스크립트 언어(Server-side scripting)를 지원한다.<br>
                        이는 서버 소프트웨어의 변경 없이도 웹 서버가 수행할 동작을 분리된 서버 사이드 스크립트 언어에 기술할 수 있다는 의미이다.<br>
                        보통 서버 사이드 스크립트 언어를 통해 구현되는 기능이란 HTML 문서를 동적으로 생성하는 것을 말한다. 이렇게 동적으로 생성된 HTML 문서는 동적 컨텐트라 하는데 주로 데이터베이스 정보를 조회해서 보여주거나 수정하기 위해 사용된다.<br>
                        동적 컨텐트와 대비되는 개념으로 정적 컨텐트가 있는데 일반적으로 동적 컨텐트보다 더 빠르게 동작하고 쉽게 캐시될 수 있지만, 반환되는 컨텐트의 내용이 항상 동일하다.<br><br>
                        웹 서버는 WWW 뿐만 아니라 프린터, 라우터, 웹 캠과 같은 임베디드 장치, 그리고 근거리 통신망(local network)에서도 사용된다. 시스템의 모니터링 또는 장치 관리를 위한 목적으로 사용되는데<br>
                        이렇게 웹 서버는 클라이언트에 다른 소프트웨어의 설치 없이 대부분의 운영체제 포함된 웹 브라우저만으로 서비스를 제공할 수 있다는 장점이 있다.
                        
                        </p>
            </ul><hr><br>
        <p style = "font-size : x-large">8. 로드 밸런싱</p><hr>
            <ul>
                <li><b>로드 밸런싱이란?</b>
                    <p>부하분산 또는 로드 밸런싱은 컴퓨터 네트워크 기술의 일종으로 중앙처리장치 혹은 기억장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미하며 서버에 가해지는 부하를 분산해주는 장치 또는 기술이다.<br>
                    사업의 규모가 확장되고, 클라이언트 수가 늘어나게 되면 기존 서버만으로는 정상적인 서비스가 불가능하게 되는데, 이런 증가한 트래픽에 대처할 수 있는 방법은 크게 두 가지이다.</p>
                        <ul>
                            <li><b>Scale up</b> : 서버 자체의 성능을 높이는 것<br><br>
                            <li><b>Scale out</b> : 여러대의 서버를 두는 것<br><br>
                        </ul>
                    <p>Scale out의 방식은 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱이 반드시 필요하다.</p>
                <li><b>로드 밸런싱 알고리즘</b><br><br>
                    <ul>
                        <li><b>라운드로반</b>
                            <p>서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식. 서버와의 연결이 오래 지속되지 않는 경우 적합하다.</p>
                        <li><b>가중 라운드로빈 방식</b>
                            <p>각 서버에 가중치를 매기고 가중치가 높은 서버에 요청을 우선적으로 배정하는 방식. 서버의 트래픽 처리 능력이 다른 경우 사용한다.</p>
                        <li><b>최소 연결 방식</b>
                            <p>요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 트래픽을 배정하는 방식. 서버에 분배된 트래픽들이 일정하지 않는 경우에 적합하다.</p>
                        <li><b>IP해시 방식</b>
                            <p>클라이언트의 IP주소를 특정 서버로 매핑하여 요청을 처리하는 방식. 사용자가 항상 동일한 서버로 연결된다.</p>
                    </ul>
                <li><b>L4 로드 밸런싱</b><br><br>
                    <ul>
                        <li>트랜스포트 계층에서 로드를 분산한다.<br><br>
                        <li>TCP, UDP 포트 정보를 바탕으로 한다.<br><br>
                        <li>데이터 안을 보지 않고 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높다.<br><br>
                        <li>섬세한 라우팅이 불가능하지만 L7로드 밸런서보다 저렴하다.<br><br>
                    </ul>
                <li><b>L7 로드 밸런싱</b><br><br>
                    <ul>
                        <li>애플리케이션 계층에서 로드를 분산한다.
                        <li>HTTP헤더, 쿠기 등과 같은 사용자 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다.<br>
                            즉, 패킷 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능하다. 특정 기능을 하는 요청이 들어오면 그 요청을 서버로 보낸다.
                        <li>더 섬세한 라우팅이 가능하고, 비정상적인 트래픽을 필터링 할 수 있다.
                        <li>패킷의 내용을 복호화 해야하기 때문에 더 많은 비용이 든다.
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">9. IPC(AF_UNIX)</p><hr>
            <ul>
                <li><b>IPC란?</b>
                    <p>프로세스는 독립적으로 실행된다. 이처럼 독립적인 공간을 가진 프로세스 간 통신에 사용되는 기법이 IPC 통신이다.<br>
                        프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스 간의 통신을 할 수 있게 된다.</p>
                <li><b>IPC의 종류</b><br><br>
                    <ul>
                        <li><b>PIPE (파이프)</b><br><br>
                            <ul>
                                <li>파이프는 두 개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고, 다른 프로세스는 데이터를 읽기만 한다<br><br>
                                <li>부모 자식 간에 단방향 통신으로 자주 사용한다<br><br>
                                <li>한쪽 방향으로만 통신이 가능한 PIPE의 특징 때문에 Half-Duplex(반이중) 통신 이라고도 불린다<br><br>
                                <li>PIPE는 반이중 통신이기에 하나의 통신선로는 읽기/쓰기 중 하나만 가능하므로 만약 읽기/쓰기, 즉 송/수신을 모두 하기 원한다면 두 개의 파이프를 만들어야 가능하다<br><br>
                                <li>read()와 write()가 기본적으로 block mode로 작동되기에 프로세스가 read 대기중이라면 read가 끝나기전에는 write를 할 수 없다<br><br>
                                
                                <li><b>장점</b>
                                    <p>PIPE는 간단하게 사용할 수 있다는 장점이 있다. 한쪽 프로세스는 단지 읽기만하고 다른 프로세스는 단지 쓰기만 하는 단순한 데이터 흐름에 적합</p>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>Full-Duplex(전이중) 통신 방식으로 활용하려면 PIPE를 두개 만들어야 하는데, 구현이 꽤나 복잡해 질 수 있다<br><br>
                                        <li>buffer가 상대적으로 작기때문에 overflow 될 확률이 높다<br><br>
                                        <li>부모 자식 관계의 프로세스들 사이에서 가능<br><br>
                                    </ul>
                            </ul>
                        <li><b>Named PIPE (익명 파이프)</b><br><br>
                            <ul>
                                <li>Linux는 모든 것을 파일(fd)로 통하고 있다는 개념을 기억하고 보자<br><br>
                                <li>Named PIPE는 통신을 할 프로세스가 명확히 알 수 있는 경우 사용<br><br>
                                <li>보통 PIPE는 부모자식간에 사용하고 Named PIPE는 전혀 모르는 상태의 프로세스들 사이에서 통신할 경우 사용<br><br>
                                <li>Named PIPE는 부모프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능한데, 이유는 프로세스간에 통신을 위해 이름이 있는 파일을 매개체로 사용하기 때문<br><br>
                                <li>mkfifo를 통해 Named PIPE를 생성하는데, mkfifo가 성공하면 이름이 명명된 파일이 생성되고 이를 활용해서 프로세스 간에 통신이 이루어짐<br><br>
                                
                                <li><b>장점</b>
                                    <p>기본 PIPE와 비슷</p>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>읽기/쓰기가 동시에 이루어지지 않음, 단방향 통신, read-only or write-only<br><br>
                                        <li>기본 PIPE와 비슷<br><br>                                        
                                    </ul>
                            </ul>
                        <li><b>Message Queue (메시지 큐)</b><br><br>
                            <ul>
                                <li>FIFO(First-In First-Out, 선입선출) 자료구조를 가지는 통신설비로 커널에서 관리<br><br>
                                <li>입출력 방식으로보면 위에 Named PIPE와 동일하다 할 수 있다<br><br>
                                <li>차이점이라면, Named PIPE는 데이터의 흐름이라면 Message Queue는 메모리 공간이라는 점<br><br>
                                <li>어디서나 물건을 꺼낼 수 있는 컨테이너 벨트와 같다 보면 된다<br><br>
                                <li>Message Queue에 쓸 데이터에 번호를 붙힘으로써 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다<br><br>
                                
                                <li><b>장점</b><br><br>
                                    <ul>
                                        <li>비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리 할 수 있다<br><br>
                                        <li>다수의 프로세스들이 큐에 메시지를 보낼 수 있고 다수의 프로세스들이 큐로부터 메시지를 꺼낼 수 있다<br><br>
                                        <li>분산처리 및 경쟁처리 방식에 사용할 수 있다<br><br>
                                    </ul>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>메시지가 정말 잘 전달되었는지 알 수 없다<br><br>
                                        <li>큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생 할 수 있다<br><br>      
                                        <li>데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다<br><br>                              
                                    </ul>
                            </ul>
                        <li><b>Shared Memory (공유메모리)</b><br><br>
                            <ul>
                                <li>프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해 주게되고, 이후 어떤 프로세스건 해당 메모리영역에 접근 할 수 있다<br><br>
                                <li>Shared Memory(공유 메모리)는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용<br><br>
                                
                                <li><b>장점</b><br><br>
                                    <ul>
                                        <li>공유 메모리는 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 모든 IPC중에서 가장 빠르게 작동한다<br><br>
                                    </ul>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>메시지 전달 방식이 아니기에 데이터를 읽어야하는 시점을 알 수 없다<br><br>
                                        <li>커널 설정에 종속적이기에 사용하기전에 커널에서 허용하고 있는 공유메모리 사이즈를 확인해야 한다<br><br>                              
                                    </ul>
                            </ul>
                        <li><b>Semaphore (세마포어)</b><br><br>
                            <ul>
                                <li>PIPE, Named PIPE, Message Queue와 같은 다른 IPC 설비들이 대부분 프로세스간 메시지 전송을 목적으로 하는데 반해, Semaphore는 프로세스 간 데이터를 동기화하고 보호하는데 그 목적이 있다<br><br>
                                <li>프로세스간 메시지 전송을 하거나 공유메모리를 통해 데이터를 공유하게 될 경우 발생하는 문제가 공유된 자원에 다수의 프로세스가 동시에 접근하면 안되며<br>
                                    단지 하나의 프로세스만 접근가능하게 해주는것이 세마포어(Semaphore) 이다<br><br>
                                <li>즉, 운영 체계 또는 프로그램 작성 내에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호<br><br>
                                <li>한 프로세스가 사용하고 있는 동안에 세마포어를 세워서 다른 프로세스를 대기시키고 사용이 끝나면 해제시키는 방법으로 사용<br><br>
                                
                                <li><b>장점</b><br><br>
                                    <ul>
                                        <li>많은 Thread들은 크리티컬 섹션을 허락받아야 한다. 즉, 크리티컬 섹션에서 충돌이 나지 않는다<br><br>
                                    </ul>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>많은 Thread들은 block을 당한다. 즉, CPU가 가만히 waiting하는 시간 낭비가 발생할 수 있다<br><br>                        
                                    </ul>
                            </ul>
                        <li><b>Memory Map (메모리 맵)</b><br><br>
                            <ul>
                                <li>파일(fd)는 리눅스의 시스템의 전역적인 자원이므로 즉, 모두 공유할수 있는 자원이므로 서로 다른 프로세스들끼리 데이터를 공유하는데 문제가 없음을 예상할 수 있다<br><br>
                                <li>메모리 맵도 공유 메모리와 마찬가지로 메모리를 공유한다는 측면에서는 비슷하다. 차이점은 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유한다는 점<br><br>
                                
                                <li><b>장점</b><br><br>
                                    <ul>
                                        <li>데이터가 메모리에 이미 올라와있는 것처럼 간단하게 접근 할 수 있다<br><br>
                                        <li>일반적인 파일 IO에 비해 나은 성능을 보여준다<br><br>
                                        <li>비동기 IO를 사용하지만 시스템에서 처리해주기 때문에 스레드 문제를 걱정할 필요 없다<br><br>
                                    </ul>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>일반 파일 IO에 비해 상당히 많은 메모리를 요구<br><br>
                                        <li>많은 데이터를 얼마나 오랫동안 메모리에 둘 것인지 컨트롤할 수 없다<br><br>                             
                                    </ul>
                            </ul>
                        <li><b>Socket (소켓, UDS = Unix Domain Socket)</b><br><br>
                            <ul>
                                <li>같은 도메인 내에서 연결 될 수 있고 프로세스들 사이의 통신을 가능하게 한다<br><br>
                                <li>서버단에서는 bind, listen, accept 진행해 소켓 연결을 위한 준비를 한다<br><br>
                                <li>클라이언트 단에서는 connect을 통해 서버에 요청하고 연결이 수립 된 후에서는 socket에 send 함으로써 데이터를 주고 받는다.<br><br>
                                <li>연결이 끝나면 반드시 close()로 clear 한다 즉, 네트워크를 통해 프로세스간에 통신을 진행한다<br><br>
                                
                                <li><b>장점</b><br><br>
                                    <ul>
                                        <li>서버/클라이언트 환경을 구축하는데 용이하다<br><br>
                                        <li>Internet Socket인 경우 데이터 유실이 발생할 수 있지만, Unix Domain소켓은 PIPE와 같은 형태로 이루어지고 같은 시스템에서 교환이 일어나므로 패킷이 유실되거나<br>
                                            순서가 바뀌는 등 문제가 발생하지 않을거라 장담 할 수 있다<br><br>
                                        <li>범용적인 IPC로써 양방향 통신이 가능하다<br><br>
                                        <li>패킷 단위로 주고 받음으로 직관적으로 이해하기 쉬운 코드를 만들 수 있다<br><br>
                                    </ul>
                                <li><b>단점</b><br><br>
                                    <ul>
                                        <li>Internet UDP와는 달리 경로를 지정할 수 없다<br><br>                         
                                    </ul>
                            </ul>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">10. 리눅스 epoll</p><hr>
            <ul>
                <li><b>epoll이란?</b>
                    <p>Epoll은 리눅스에서 select의 단점을 보완하여 사용할 수 있도록 만든 I/O통지 모델이다.<br>
                    select()를 사용할 때에는, 유저가 관찰할 파일 디스크립터 배열을 가지고 있고 select함수가 호출될 때마다 전체 파일 디스크립터가 해당 배열로 복사된다.<br>
                    하지만 epoll에서는 커널 공간이 파일 디스크립터를 관리하고 변경된 파일 디스크립터만을 유저에게 통지해 주기 때문에 select보다 빠르게 동작할 수 있다.<br><br>
                    epoll은 리눅스에서 제공하는 시스템 콜이기 때문에 다른 운영체제로의 이식성이 떨어지는게 단점이다.</p>
                <li><b>관련 함수</b><br><br>
                    <ul>
                        <li><b>epoll_create</b>
                            <p>커널 공간에 epoll 파일 디스크립터를 생성하는 함수. 리눅스 2.6.8부터는 인자인 size를 무시하기 때문에 0 이상의 값으로만 넣어주면 된다. epoll_create1은 size대신 flag를 받는다.</p>
                        <li><b>epoll_ctl</b>
                            <p>epoll에 관찰 대상인 파일 디스크립터를 등록하는 함수. 첫 번째 인자부터 순서대로 epoll fd, 옵션, 대상 파일 디스크립터, 이벤트 구조체이다.</p>
                        <li><b>epoll_wait</b>
                            <p>epoll_ctl로 등록한 파일 디스크립터의 변화를 탐지한다.</p>                      
                    </ul>
            </ul><hr><br>
    </body>
</heml>