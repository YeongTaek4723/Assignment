<html>
    <head>
        <title>2week_1 Assignment</title>
    </head>
    <body>
        <p style = "font-size : x-large">1. IDC</p><hr>
            <ul>
                <li><b>IDC의 정의</b></li><br>
                    <ul>
                        <li>IDC는 Internet Data Center의 약자로 서버 컴퓨터와 네트워크 회선등을 제공하는 서버 호텔(Server Hotel)이라고도 불리우며, 방대한 정보저장을 위한 수만 대의 서버<br>
                        컴퓨터를 안정적으로 관리하기 위하여 설립된 데이터 보안, 보관 시설을 의미한다.<br><br>
                    <li>서버들을 한 장소에서 보관하기 떄문에 전문적인 관리, 안정성 및 네트워크 속도, 보안, 비용절감등의 장점이 있다.<br><br>
                    <li>클라우드 서비스(Cloud service), 코로케이션 서비스(Colocation Service), 호스팅 서비스(Hosting Service)등으로 구분할 수 있다.<br><br>
                    </ul>
                <li><b>클라우드 서비스(Cloud service)</b>
                    <p>컴퓨팅, 저장 공간, 통신, 보안 서비스를 통칭하며 서비스 제공자가 서버 등 하드웨어를 소유하고 운영하기 때문에 고객은 데이터센터에 대해 신경쓰지 않아도 된다.</p>
                <li><b>코로케이션 서비스(Colocation Service)</b>
                    <p>상면형 서비스와 가상 IDC서비스로 나뉜다.</p>
                    <ul>
                        <li><b>상면형 서비스</b>                  
                            <p>상면형 서비스는 기업 또는 개인을 대상으로 IDC의 일정 공간을 임대해주는 형태의 서비스를 의미한다.</p>
                        <li><b>가상 IDC서비스</b>
                            <p>가상 IDC서비스는 독자적인 IDC시설을 보유하고 있지 않은 채 IDC의 일정 공간을 임대 받아 고객에게 코로케이션,호스팅을 제공하는 재임대형 서비스를 의미한다.</p>
                    </ul>
                <li><b>호스팅 서비스(Hosting Service)</b>
                    <p>단독 서버 제공 여부에 따라 웹 호스팅과 서버 호스팅으로 나뉜다. </p>
                    <ul>
                        <li><b>웹 호스팅</b>
                            <p>웹 호스팅은 다수의 사용자와 하나의 서버 공간을 함께 사용하는 것이라 할 수 있다.</p>                        
                        <li><b>서버 호스팅</b>
                            <p>서버 호스팅은 전문적인 인터넷 비즈니스를 위하여 한 대의 단독서버를 사용하면서 서버운영에 필요한 전용회선과 네트워크 관리 서비스 등 필요한<br>
                            일체의 장비 및 기술력을 제공받는 서비스이다.</p>
                    </ul>
                <li>데이터센터는 24시간, 365일 중단 없는 서비스 제공을 위해 전력공급과 인터넷 연결 및 보안이 매우 중요하다. 현재 대부분의 데이터센터는<br>
                    높은 토지매입 유지비용에도 불구하고 서비스 지연들을 최소화하기 위해 사용자가 밀집해 있는 대도시나 인근 지역에 위치해 있다.<br><br>
                <li>우리나라의 경우에도 고객과의 접근성이 좋고 네트워크 인프라가 잘 구비되어 있으며 인력의 가용성과 유지 보수가 용이한 수도권에 집중되어있고<br>
                    최근에는 데이터센터간 네트워크 연동기술 발달로 고객과의 거리적 제약이 완화됨에 따라 기업들은 구축 유지비용, 네트워크 인프라 인력, 자연재해 위험 등을<br>
                    종합적으로 감안하여 입지를 결정한다.
            </ul><hr><br>
        <p style = "font-size : x-large">2. IaaS</p><hr>
            <ul>
                <li><b>IaaS란?</b></li>
                    <p>Infrastructure as a Service의 약자이며, 클라우드를 통해 기업 및 개인에게 컴퓨팅, 스토리지, 네트워킹, 가상화와 같은 인프라 리소스를 제공하는 클라우드 서비스 모델이다.</p>  
                <li><b>IaaS 설명</b></li>
                    <p>클라우드 컴퓨팅에서 IaaS는 서버, 가상 머신, 네트워킹 리소스, 스토리지를 포함하여 클라우드 서비스 제공업체(CSP)로부터 클라우드 인프라 리소스 액세스를 개별 서비스로 대여하는 서비스이다.<br>
                    IaaS는 온프레미스 데이터 센터에서 물리적 인프라 구축 및 유지보수와 관련된 비용과 복잡성을 상당 부분 없애준다.<br><br>
                    CSP가 인프라 관리 및 유지보수를 책임지기 때문에 소프트웨어 설치, 구성, 관리 및 데이터 보안 유지에 집중할 수 있다.<br>
                    IaaS 제공업체는 또한 세부적인 청구 관리, 로깅, 모니터링, 스토리지 복원력, 보안과 같은 추가적인 서비스를 제공한다.<br><br>
                    사용한 만큼만 지불 기준을 사용하여 IaaS 리소스에 엑세스 할 수 있으므로, 필요한 리소스 사용 비용만 지불할 수 있다. 즉, 리소스를 쉽게 증감할 수 있으므로 필요할 때 비용을 줄이고<br>
                    새로운 수요에 맞게 리소스를 즉시 프로비저닝하고 수평 확장할 수 있다.</p>
                <li><b>IaaS의 이점</b><br><br>
                    <ul>
                        <li><b>비용 절감</b>
                            <p>IaaS는 초기 자본 지출을 줄여준다. 리소스가 주문형으로 사용되므로 소비하는 컴퓨팅, 스토리지, 네트워킹 리소스에 대해서마 지불하면 된다.<br>
                            IaaS 비용은 쉽게 예측 가능하며 억제하고 예산을 책정할 수 있다.</p>
                        <li><b>효율성 향상</b>
                            <p>IaaS 리소스는 필요할 때 기업에 정기적으로 제공된다. 따라서 조직은 인프라를 확장할 때 프로비저닝 지연 시간을 줄이고 과도한 용량 구축으로 인한 리소스 낭비를 방지할 수 있다.</p>
                        <li><b>짧은 지연 시간</b>
                            <p>대부분의 클라우드 서비스 제공업체는 여러 지역에 걸쳐 있는 글로벌 네트워크를 통해 가용성과 복원력을 향샹시킨다.<br>
                                최종 사용자와 가장 가까운 리전 및 영역에 앱 및 서비스를 배치하여 지연 시간을 최소화하고 성능을 늘릴 수 있다.</p>
                        <li><b>높은 확장성</b>
                            <p>클라우드 컴퓨팅에서 IaaS의 가장 큰 이점 중 하나는 리소르를 빠르게 증감할 수 있는 자동 확장/축소 기능이다.<br>
                            갑작스러운 수요 급증을 거의 즉각적으로 처리하고 리소스가 더 이상 사용되지 않으면 다시 규모를 축소할 수 있다.</p>
                    </ul>              
            </ul><hr><br>
        <p style = "font-size : x-large">3. PaaS</p><hr>
        <ul>
            <li><b>PaaS란?</b></li>
                <p>PaaS는 Platform as a Service의 약자로 일종의 클라우드 컴퓨팅 서비스 모델로서 앱을 개발, 배포, 실행, 관리할 수 있는 유연하고 확장 가능한 클라우드 플랫폼을 제공한다.</p>  
            <li><b>PaaS 설명</b></li>
                <p>IaaS 또는 SaaS 서비스 모델과는 달리 PaaS는 애플리케이션 및 소프트웨어 개발 전용이며, 일반적으로 다음이 포함된다.</p>
                <ul>
                    <li><b>클라우드 인프라</b> : 데이터 센터, 스토리지, 네트워크 장비 및 서버<br><br>
                    <li><b>미들웨어 소프트웨어</b> : 운영체제, 프레임워크, 개발 키트(SDK), 라이브러리 등<br><br>
                    <li><b>사용자 인터페이스</b> : 그래픽 사용자 인터페이스(GUI), 명령줄 인터페이스(CLI), API 인터페이스 및 일부 경우 이 세가지 모두<br><br>
                </ul>
            <li>PaaS는 일반적으로 개발자가 인터넷을 통해 엑세스할 수 있는 안전한 온라인 플랫폼으로 제공되므로 어디서나 프로젝트를 작업하고 다른 팀원과 자유롭게 공동작업할 수 있다.<br>
                또한 애플리케이션을 PaaS 시스템에서 직접 빌드하여 완성 즉시 배포할 수 있다.<br><br>
            <li><b>PaaS의 이점</b><br><br>
                <ul>
                    <li><b>TTM(Time To Market)단축</b>
                        <p>복잡한 리프트 절차가 필요하지 않아 개발자가 빌드 또는 관리할 필요가 없는 완벽한 애플리케이션 개발 플랫폼에 즉시 액세스할 수 있으므로 개발 및 배포 시간이 확보된다.</p>
                    <li><b>효율적인 가격 책정</b>
                        <p>PaaS리소스는 주문형 리소스이므로 실제로 사용한 만큼만 비용을 지불하면 된다. 또한 PaaS에서는 구매하려면 많은 비용이 들 고급 개발 도구와 기능도 사용할 수 있다.</p>
                    <li><b>유지보수 수요 감소</b>
                        <p>사내 애플리케이션 스택에서는 특히 업그레이드와 관련된 문제가 많이 발생한다. 하지만 PaaS에서는 제공업체가 모든 항목을 최신 상태로 유지해주어 보수 작업을 직접 수행할 필요가 없다.</p>
                    <li><b>쉬운 확장성</b>
                        <p>트래픽이 적은 기간에 맞게 축소하거나 예기치 않게 급증하는 수요에 맞게 즉시 확장할 수 있다.</p>
                </ul>              
        </ul><hr><br>
        <p style = "font-size : x-large">4. SaaS</p><hr>
        <ul>
            <li><b>SaaS란?</b></li>
                <p>SaaS는 Software as a Service의 약자로 인터넷 브라우저를 통해 최종 사용자에게 애플리케이션을 제공하는 클라우드 기반 소프트웨어 모델이다.</p>  
            <li><b>SaaS 설명</b></li>
                <p>SaaS는 클라우드 제공 모델을 통해 작동한다. SaaS 공급업체는 일반적으로 자체 서버 및 데이터베이스에서 애플리케이션 및 데이터를 호스팅하거나 서드 파티 클라우드 제공업체의 서버를 활용하며<br>
                또한 플랫폼, 운영 체제 및 미들웨어를 관리한다.</p>
            <li><b>SaaS의 이점</b><br><br>
                <ul>
                    <li><b>빠른 배포</b>
                        <p>SaaS를 사용하면 온프레미스 소프트웨어와 관련된 설치 및 구성이 필요하지 않다. 따라서 엔터프라이즈 구독을 시작하는 즉시 비즈니스 전체에 소프트웨어를 롤아웃할 수 있다.</p>
                    <li><b>저렴한 결제 비용</b>
                        <p>SaaS 공급업체는 일반적으로 구독 기반 모델을 제공한다. 따라서 라이선스, 설치 또는 인프라 관리 등 기존 소프트웨어에서 발생하는 선결제 비용이 줄어든다.<br>
                        또한, 공급업체가 서버의 모든 것을 관리하므로 추가 컴퓨팅 리소스에 대한 투자 없이 소프트웨어를 실행할 수 있다.</p>
                    <li><b>신뢰성</b>
                        <p>SaaS 제공업체는 엄격한 사이버 보안 프로토콜과 재해 복구 기능에 많은 투자를 한다. 따라서 신뢰할 수 있는 인터넷 연결만 있으면 작업을 시작할 수 있다.</p>
                    <li><b>실시간 데이터 및 분석</b>
                        <p>SaaS 애플리케이션은 사용량 및 성능에 관한 데이터를 수집하고 실시간으로 인사이트를 제공할 수 있다.</p>
                    <li><b>통합</b>
                        <p>API를 사용하여 SaaS 애플리케이션을 다른 플랫폼 및 시스템과 통합할 수 있다. 인프라 비용을 들이지 않고도 특정 요구 사항에 적합하게 소프트웨어를 사용자가 지정할 수 있다.</p>
                    <li><b>자동 업데이트</b>
                        <p>소프트웨어 공급업체는 정기적으로 증분 업데이트 및 보안 패치를 소프트웨어에 적용한다. IT팀의 지원 없이 자동 업데이트를 배포하도록 설정할 수 있다.</p>
                </ul>              
        </ul><hr><br>
        <p style = "font-size : x-large">5. grep</p><hr>
            <ul>
                <li><b>grep란</b>
                    <p>grep는 입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자할 때 사용하는 리눅스 명령어로 갖아 많이 사용되는 명령어 중 하나다.</p>
                <li><b>사용법</b>
                    <p>grep[옵션][패턴][파일명]</p>
                <li><b>자주 사용하는 옵션</b></li><br>
                    <ul>
                        <li><b>-c</b> : 일치하는 행의 수를 출력한다.<br><br>
                        <li><b>-i</b> : 대소문자를 구별하지 않는다.<br><br>
                        <li><b>-v</b> : 일치하지 않은 행만 출력한다.<br><br>
                        <li><b>-n</b> : 포함된 행의 번호를 함께 출력한다.<br><br>
                        <li><b>-l</b> : 패턴이 포함된 파일의 이름을 출력한다.<br><br>
                        <li><b>-w</b> : 단어와 일치하는 행만 출력한다.<br><br>
                        <li><b>-x</b> : 라인과 일치하는 행만 출력한다.<br><br>
                        <li><b>-r</b> : 하위 디렉토리를 포함한 모든 파일에서 검색한다.<br><br>
                        <li><b>-m 숫자</b> : 최대로 표시될 수 있는 결과를 제한한다.<br><br>
                        <li><b>-E</b> : 찾을 패턴을 정규 표현식으로 찾는다.<br><br>
                        <li><b>-F</b> : 찾을 패턴을 문자열로 찾는다.<br><br> 
                    </ul>
                <li><b>grep의 종류</b></li><br>
                    <ul>
                        <li><b>grep</b>   : 다중 패턴을 검색한다.           / 정규표현식 사용 O<br><br>
                        <li><b>egrep</b>  : 정규 표현식 패턴을 검색한다.    / 정규표현식 사용 O<br><br>
                        <li><b>fgrep</b>  : 문자열 패턴으로 검색한다.       / 정규표현식 사용 X<br><br>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">6. netstat</p><hr>
            <ul>
                <li><b>netstat의 정의</b>
                    <p>netstat(network statistics) 명령어는 정송 제어 프로토콜, 라우팅 테이블 등 수 많은 네트워크 인터페이스(네트워크 인터페이스 컨트롤러 또는 소프트웨어 정의 네트워크 인터페이스)<br>
                    네트워크 프로토콜 통계를 위한 네트워크 연결을 보여주는 명령 줄 도구이다.</p>
                <li><b>netstat 명령어</b><br><br>
                    <ul>
                        <li><b>프로토콜</b> : 사용하는 프로토콜(TCP/UDP)<br><br>
                        <li><b>로컬주소</b> : 활성화 되어있는 사용자 컴퓨터의 IP/호스트네임과 ":"뒤에 포트번호<br><br>
                        <li><b>외부주소</b> : 사용자의 PC와 연결되어 있는 IP/호스트네임과 ":"뒤에 포트번호<br><br>
                        <li><b>상태</b>     : 연결된 상태에대한 정보<br><br>
                            <ul>
                                <li><b>LISTENING</b>    : 연결 요청을 기다리고 있는 상태(포트 열려있음)<br><br>
                                <li><b>ESTABLISHED</b>  : 3way handshake 진행 후 연결이 성립되어있는 상태<br><br>
                                <li><b>TIME_WAIT</b>    : 종료 준비가 끝났으나 원격의 수신 보장을 위해 기다리는 상태<br><br>
                                <li><b>SVN_SENT</b>     : 로컬에서 원격으로 연결을 요청(SYN 신호를 보냄)을 시도한 상태<br><br>
                                <li><b>SVN_RECV</b>     : 원격으로부터 연결 요청을 받은 상태. 요청을 받아서 SYN + ACK 신호로 응답한 후, ACK를 대기하고 있는 상태<br><br>
                                <li><b>CLOSE_WAIT</b>   : 원격이 종료 요청을 받고 연결이 종료되기를 기다리는 상태. 원격으로 부터 FIN + ACK 신호를 받고, ACK신호를 원격으로 보냄<br><br>
                                <li><b>CLOSED</b>       : 연결이 종료된 상태<br><br>
                                <li><b>LAST_ACK</b>     : 원격지로부터 FIN 요청을 받고 연결을 종료한 상태<br><br>
                                <li><b>UNKNOWN</b>      : 소켓 상태에 대한 확인이 불가능한 경우<br><br>
                            </ul>
                    </ul>
                <li><b>netstat 명령어 옵션</b><br><br>
                    <ul>
                        <li><b>-a</b> : 현재 다른 서버 또는 PC와 연결, 리스닝 되어있는 모든 포트 번호를 확인한다.<br><br>
                        <li><b>-n</b> : 현재 다른 서버 또는 PC와 연결되어 있는 포트 번호를 확인한다.<br><br>
                        <li><b>-s</b> : IP, ICMP, UDP 프로토콜의 상태 확인한다.<br><br>
                        <li><b>-u</b> : UDP 프로토콜을 보여준다.<br><br>
                        <li><b>-t</b> : TCP 프로토콜을 보여준다.<br><br>
                        <li><b>-c</b> : 1초 단위로 보여준다.<br><br>
                        <li><b>-p</b> : 프로토콜에서 사용 PID를 보여준다.<br><br>
                        <li><b>-e</b> : 랜카드에서 송수신한 패킷의 정보를 확인한다.<br><br>
                        <li><b>-r</b> : 라우팅 테이블 확인과 연결된 있는 포트 번호를 확인한다.<br><br>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">7. ufw</p><hr>
            <ul>
                <li><b>ufw란?</b>
                    <p>UFW(Uncomplicated Firewall)는 데비안 계열 및 다양한 리눅스 환경에서 작동되는 사용하기 쉬운 방화벽 관리 프로그램이다.<br><br>
                    UFW는 사용하기 쉽게 설계된 넷필터 방화벽을 관리하는 프로그램이다. 간단한 명령 및 명령수가 적은 명령줄 인터페이스를 사용하는 것이 특징이며 프로그램 구성에는 iptables를 사용한다.<br>
                    UFW는 기본적으로 18.04 LTS 이후의 모든 데비안 및 우분투에서 사용할 수 있다.</p>
                <li><b>UFW 사용법</b><br><br>
                    <ul>
                        <li><b>UFW 활성/비활성화</b><br><br>
                            <ul>
                                <li>UFW는 기본적으로 비활성화 상태이기에 이를 활성화한다. -> <b>sudo ufw enable</b><br><br>
                                <li>UFW 비활성화 -> <b>sudo ufw disable</b><br><br>
                                <li>UFW 상태 확인 -> <b>sudo ufw status verbose</b><br><br>
                            </ul>
                        <li><b>UFW 기본 룰</b><br><br>
                            <ul>
                                <li>들어오는 패킷에 대해서는 전부 거부(deny)<br><br>
                                <li>나가는 패킷에 대해서는 전부 허가(allow)<br><br>
                                <li>기본 룰 확인 -> <b>sudo ufw show raw</b><br><br>
                                <li>기본 정책 차단 -> <b>sudo ufw default deny</b><br><br>
                                <li>기본 정책 허용 -> <b>sudo ufw default allow</b><br><br>    
                            </ul>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">8. service</p><hr>
            <ul>
                <li><b>Service 란?</b>
                    <p>사용자가 다른 애플리케이션으로 전환하더라도 백그라운드에서 계속해서 실행할 수 있도록 하는 안드로이드 컴포넌트이다. 이외에도 구성요소를 서비스에 바인딩하여 서비스와 상호작용 할 수 있다.</p>
                <li><b>Service의 유형 3가지</b>
                    <p>서비스가 시작되었거나, 바인드가 되었던, 양쪽 모두이든 모든 어플리케이션 구성요소가 해당서비스를 사용할 수 있다. 이것을 Intent로 시작할 수 있다.</p>
                    <ul>
                        <li><b>포그라운드</b>
                            <p>사용자에게 보이는 작업을 수행, 화면에 보여지는 작업을 포그라운드라고 한다.</p>
                        <li><b>백그라운드</b>
                            <p>사용자에게 보이지 않는 작업을 수행</p>
                        <li><b>바인드</b>
                            <p>애플리케이션 구성요소가 BindService()를 호출하여 해당 서비스에 바인딩한다.<br>
                            바인딩 된 서비스를 클라이언트 - 서버 인터페이스를 제공하여 구성요소가 서비스와 상호작용하게 해주며, 바인딩 해제되면 해당 서비스는 소멸한다.</p>
                            <ul>
                                <li><b>onStartCommand()</b> : 구성요소가 서비스를 시작하게한다.
                                    <p>시스템이 이 메서드를 호출 하는 것은 구성요소가 서비스를 시작하도록 요청하는 경우. 이 메서드가 실행되면 서비스가 시작되고 무한히 실행 가능</p>
                                    <ul>
                                        <li><b>onStartCommand()의 리턴 타입 3가지</b>
                                            <p>Service는 실행시 startService를 호출하는데 onStartCommand에 intent로 value를 넘겨줄 수 있다.</p>
                                            <ul>
                                                <li><b>START_STICKY</b>
                                                    <p>서비스가 강제 종료되었을 경우, 기존에 intent에 value값이 설정되어 있다고 하더라도 시스템이 Service 재시작 시 intent값을 null로 초기화시켜 재시작한다.</p>
                                                <li><b>START_NOT_STICKY</b>
                                                    <p>flag를 리턴해주면, 강제로 종료 된 서비스가 재시작하지 않는다. 따라서 시스템에 의해 강제 종료되어도 괜찮은 작업에 사용한다.</p>
                                                <li><b>START_REDELIVER_INTENT</b>
                                                    <p>START_STICKY와 마찬가지로 Service가 종료되어도 시스템이 다시 Service를 재시작시켜주지만 intent 값을 그대로 유지시켜 준다.<br>
                                                    startService() 호출 시 intent value 값을 사용한 경우라면, 이 flag를 사용해서 리턴 값을 설정해주면 된다.</p>
                                            </ul>
                                    </ul>
                                <li><b>onBind()</b> : 바인드를 허용한다.
                                    <p>시스템은 구성 요소가 해당 서비스에 바인딩되고자 하는 경우</p>
                                    <ul>
                                        <li>바인딩을 허용하지 않을 경우 : null 반환<br><br>
                                        <li>바인딩을 허용할 경우 : 이 메서드를 구현할 때는 클라이언트와 서비스가 통신을 주고 받기위해 사용할 인터페이스를 제공해야한다. 이때, lbinder반환
                                    </ul>
                            </ul>
                    </ul>
            </ul>
        <hr><br>
        <p style = "font-size : x-large">9. branch</p><hr>
            <ul>
                <li><b>branch란?</b>
                    <p>branch는 나뭇가지라는 뜻으로 개발을 하다보면 원래 코드와 상관없이 독립적으로 개발을 진행하는 경우가 생기는데 이 때 독립적으로 개발을 도와주는 것이 branch이다.</p>                  
                <li><b>branch 명령어</b><br><br>
                    <ul>
                        <li><b>브랜치 리스트 확인하기</b>
                            <p>현재 내가 사용하고 있는 브랜치는 초록색 글씨로 되어있다.<br>
                            -> <b>git branch</b></p>
                        <li><b>브랜치 만들기</b>
                            <p>현재 속해있는 브랜치 상태를 가진 새 브랜치가 생성된다.<br>
                            -> <b>git branch [브랜치이름]</b></p>
                        <li><b>브랜치 삭제</b>
                            <p>원하는 브랜치가 삭제된다.<br>
                            -> <b>git branch -d [브랜치이름]</b></p>
                        <li><b>브랜치 바꾸기</b>
                            <p>-> <b>git checkout [-b] [브랜치이름]</b></p>
                            <ul>
                                <li><b>-b</b> : 새 브랜치를 생성하고 바꾼다.<br><br>
                                <li>브랜치이름에 커밋해시값을 넣으면 새 브랜치를 생성하고 커밋시점 버전으로 생긴다.<br><br>
                            </ul>
                        <li><b>두 브랜치의 커밋 상태 차이 보기</b>
                            <p>브랜치1에는 없고 브랜치2에 있는 커밋들의 로그를 보여준다.<br>
                            -> <b>git log [-p] [브랜치1]..[브랜치2]</b><br><br>
                            <b>-p</b> : 두 브랜치 사이 소스코드 차이도 알고싶을 때 사용한다.</p>
                        <li><b>두 브랜치의 커밋 상태 차이 보기</b>
                            <p>git log는 현재 브랜치의 커밋 로그들을 보여준다. 전체 브랜치에 대한 커밋 상태보기는 다음과 같다.<br>
                            -> <b>git log --branches --decorate --graph --oneline</b></p>
                            <ul>
                                <li><b>--branches</b> : 각 브랜치가 어떤 커밋을 가르키고 있는지 알려준다. 이 옵션이 없으면 HEAD만 보여준다.<br><br>                              
                                <li><b>--decorate</b> : 브랜치의 참조 정보를 알려준다.<br><br>
                                <li><b>--graph</b>    : 커밋 이력을 텍스트 기반 그래픽으로 표현한다. 이로 인해 그래프 히스토리가 어떻게 가지가 뻗었는지 가시적으로 보여준다.<br><br>
                                <li><b>--oneline</b>  : 그래프의 상황을 간결하게 보여준다.<br><br>
                            </ul>
                        <li><b>각 브랜치의 현재 상태 비교</b>
                            <p>-> <b>git diff</b></p>
                        <li><b>브랜치 병합</b>
                            <p>브랜치에서 작업한 내용을 master로 병합하려한다. 즉, 브랜치의 커밋을 master도 가지게 할 것이다. 이 때 master에서 병합을 진행해야한다.<br>
                            -> <b>git merge [브랜치이름]</b></p>
                            <p>병합의 방법에는 두가지가 있다.</p>
                            <ul>
                                <li>Fast-forward<br><br>                                 
                                <li>2-way Merge
                            </ul>
                    </ul>
            </ul><hr><br>
        <p style = "font-size : x-large">10. stash</p><hr>
            <ul>
                <li><b>git stash 란?</b>
                    <p>git stash란 변경사항을 임시로 저장할 수 있도록 도와주는 기능이다.<br>
                    커밋을 하기에는 너무 경미한 변경이나 갑작스러운 핫픽스 요청과 같은 상황이 발생했을 때 브랜치를 변경해야하는 경우 커밋 대신에 임시로 저장하는 기능이라 생각하면 된다.<br>
                    브랜치를 변경해야 하는 경우 전체 조건은 Index Storage의 데이터를 비워야 한다.<br>
                    즉, 커밋을 하거나 stash를 이용해 저장을 해야만 하는데 많은 변경의 경우 커밋을 진행하고 아니라면 stash를 하는 방향을 생각하면 좋다.</p>
                </li><b>stash 명령어</b><br><br>
                    <ul>
                        <li><b>git stash</b>
                            <p>하던 작업을 임시로 저장한다.</p>
                        <li><b>git stash list</b>
                            <p>stash 목록을 확인할 수 있다.</p>
                        <li><b>git stash apply</b>
                            <p>stash 했던 작업을 가져온다.</p>
                        <li><b>git stash pop</b>
                            <p>가장 최근의 stash를 제거한다.</p>
                        <li><b>git stash show -p | git apply -R</b>
                            <p>실수로 잘못 적용한 stash를 되돌린다.</p>
                    </ul>           
            </ul><hr><br>
    </body>
</html>